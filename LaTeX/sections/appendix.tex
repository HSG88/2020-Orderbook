% !TEX root = ../main.tex


\section{Extended Discussion on Cleaning up Data Structures on Ethereum}

As discussed in Section~\ref{sec:gasrefund}, whether to clean up storage variables or not remains a vital challenge for developers when developing DApps on the Ethereum blockchain--- this is even more crucial for implementation of \cm, as we need to choose the best middle ground design model which gives us optimized performance and cost results. For this reason, we believe it it is helpful (both for researchers and developers) to extend our discussion on this topic. First, we discuss the Ethereum's gas model--- (i) what are different gas parameters one needs to take into account when sending a transaction on the Ethereum blockchain, (ii) what is the gas refund, and (iii) and how it is calculated.  Next, we discuss one major challenge, \textit{clearing mappings}, that we faced when implementing \cm on the Ethereum.


\subsection{Ethereum's Gas Model} 

Gas is the Ethereum's pseudo-currency and a key variable for the execution of smart contracts. DApps written in high-level programming languages are compiled and translated into a compact representation (called ‘bytecode’) to be further executed on the Ethereum virtual machine or EVM. Each of these opcodes has a fixed amount of gas assigned and is a measure of computational effort. Separating ETH from gas prevents transaction costs from being too expensive as they are less impacted by ETH price fluctuations. Gas unit does not a have a monetary value and as mentioned, it only  measures the computational work undertaken by miners. To pay miners, Ethereum introduces a \texttt{gas price} --- small denomination of ether called \textbf{Gwei} attached to each gas unit. Essentially, gas price indicates how much users are willing to pay per unit of gas--- clearly a higher gas price leads to the faster execution of a transaction. Miners also need to know the total amount of computational work a user is requesting, called the \texttt{gas limit}. \texttt{Gas limit} is a parameter that limits the amount of gas users would spend in a transaction, it protects users from spending unlimited ETH on their transactions and must be set carefully. If the \texttt{gas limit} is too low, the transaction will exceed the limit and all operations will be reverted while the user must pay for the computational work performed by the miner. By default the gas limit for an Ethereum transaction is 21,000 gas. An Ethereum block also has a \texttt{block gas limit} field which is set by the Ethereum miners and indicates the maximum amount of gas all the transactions in that block are allowed to consume, the Ethereum \texttt{block gas limit} is currently 11,741,495. \footnote{July 2020: https://ethstats.net/} 


\subsubsection*{Gas Refunds.}There are two particular EVM operations with negative gas--- certain amount of gas is refunded to the sender at the end of the transaction. These operations include:

\paragraph{\texttt{SELFDESTRUCT}.}This operation destroys the originating contract and refunds its balance (if any) to a designated receiver address. Note that the Ethereum storage is implemented in the form of a has map and EVM is not statistically aware of which storage slots are held by the contract. So the \texttt{SELFDESTRUCT} operation does not remove the initial byte code of the contract from the chain, but it frees up the state storage and has a refund of 24,000 gas.

\paragraph{\texttt{SSTORE}.} This operation clears the Ethereum storage and has15,000 gas refunds. 

Note that in order to urge miners to process smart contracts with refunds, the accumulated gas refund can never exceed half the gas used up during computation~\cite{wood2014ethereum}. So at the end of a successful transaction, the amount of gas in the refund counter (capped at half the net gas used) is returned to the caller. At the time of this writing, Ethereum transaction receipts only account for the \texttt{gasUsed}, which is the total amount of gas units spent during a transaction, and users are not able to obtain the value of the EVM's refund counter from inside the EVM~\cite{signer2018gas}. So in order to account for refunds, we can only calculate them manually; first we need to figure out exactly how much storage is being cleared or how many smart contracts are being destroyed, then we multiply these numbers by 24,000 and 15,000 respectively. 


\subsection{Clearing Mappings}

To maintain the ETH and token balances of each trader in \cm, we use one-to-one mappings, \texttt{totalBalance} and \texttt{unavailableBalance}, that map Ethereum addresses to unsigned integers. Note that we need to clear up the entire  \texttt{unavailableBalance} mapping during the orders settlement and clearing phase. However in Solidity, it is not possible to delete the entire mapping without knowing the keys~\footnote{In a Solidity mapping, only individual keys and what they map to can be deleted: https://solidity.readthedocs.io/en/v0.5.12/security-considerations.html}. Here we propose and discuss the landscape of various solutions together with how each method affects the total amounts of gas costs for clearing orders in \cm.

\begin{enumerate}

%---------+++++++++++++++++++-----------------
\item \textbf{Storing mapping keys in additional array.} This is a common design pattern used by DApp developers--- to delete the mapping, one needs to create an additional array on top of it and iterate over that array. For example in \cm, we can create \texttt{address[] helperArray} that stores traders' addresses. Knowing traders addresses (\ie mapping keys), we can now iterate over the mapping and delete these individual keys and what they map to at the end of the matching/clearing process. Despite being a common design pattern, this solution 
significantly increases the total cost of matching the orders as Solidity loops are costly operations. 


%---------+++++++++++++++++++-----------------
\item \textbf{Storing the mapping in a separate smart contract.} Another design proposal is to create a new smart contract every time the market opens. This contract \textit{only} stores the \texttt{unavailableBalance} mappings and will be destroyed (using the \texttt{SELFDESTRUCT} operation) at the end of the matching process. This solution assigns overhead costs to the \texttt{matchOrders()} function as it involves an external call to another smart contract (\ie destroy the contract containing the mappings).


%---------+++++++++++++++++++-----------------
\item \textbf{Generating custom mapping keys.} We can also define a global counter variable and use it as a custom key for the mappings. This counter is incremented \textit{only once} at the end of the matching process. So we only use a new portion of the mapping (and leave the used portion on the Ethereum blockchain) every time the market opens. This solution removes the burden of the gas cost from the \texttt{matchOrders()} function (as discussed in Section~\ref{sec:gasrefund}, leaving the data on chain is cheaper than cleaning it up), however DApp developers are advised to be good citizens of Ethereum and cleanup on-chain data they no longer need. 

%---------+++++++++++++++++++-----------------
\item \textbf{Creating a new mapping every time the market opens.} Similar to the previous proposal, we can skip deleting mappings and instead create a new mapping every time the market opens. Again, although this method does not increase the cost of matching the orders in \cm, it leaves unused data on the Ethereum blockchain. 



%---------+++++++++++++++++++-----------------
\end{enumerate}


%gas price: how much you pay per gas unit
%gas limit: how much work you are requesting 
%gas cost (Ether) = gasPrice * gasCost(gas)
%gas limit: is a parameter that limits the amount of gas you spend in a transaction (how to estimate? using estimateGas)
%gas price how to estimate: using ethgassation 
%by defaluth the gas minimum gas limit for ethereum txs is 21000 gas
%a block also has a gas limit field, it defines a maximum amount of gas all txs in th eblock combined are allowed to consume. this block gas limit determines the maximum number of transactions within the block. this block gas limt is not fixed and set by miners  
%
%ers to process smart contracts with refunds, the accumulated gas refund can never exceed half the gas used up during computation~\cite{wood2014ethereum}. So at the end of a successful transaction, the amount of gas in the refund counter (capped at half the net gas used) is returned to the caller. 


% \input{tables/eval.tex}

%\section{Rollups}
%
%\subsection{Using Rollups.} Rollup is a scaling method that moves the storage and computation of the smart contracts off-chain while maintaining the transaction data on the main chain as call-data. In this technique, any Ethereum user can act as a validator; they can execute the \texttt{CloseMarket()}function and only post the new state of the contract (the updated balance of traders) in the form of \textit{assertions} to the main chain. Rollups improve scalability, provide faster and cheaper execution of the contracts, and eliminate the gas limit as the contract is no longer executed on-chain.
%
%In the followings we briefly discuss different rollup proposals and techniques. Each approach uses a different method to ensure correction of assertions:
%
%\paragraph{Non-interactive Rollups.} In this rollup technique, assertions are posted together with a validity proof that would be later used by validators to check if the \texttt{CloseMarket()} function has been executed correctly. ZK-Rollup scheme is one of the solutions that uses ZK-SNARKs to prove the validity of the assertions in zero-knowledge. ZK proofs are quick and cheap to verify but they are expensive and time consuming to generate. These proofs could be generated (i) for free or (ii) the CallMarket contract could collect proportional fees for every trade that is successfully executed.
%
%\paragraph{Optimistic Rollups.} In this scheme, assertions are assumed to be valid if there is no dispute posted about them with a certain window of time (a.k.a. "the challenge period'). Here, dispute resolution is a gas-costly method as the CallMarket contract would have to emulate the transaction on-chain to ensure the correctness the assertion. This scheme introduces a tradeoff between privacy and performance as all the assertions are publicly available and accessible. However, here the new state only reflects the updated balances of traders and no secret is involved. 
%
%\paragraph{{Multi-round Interactive Rollups.}} In this design paradigm, \textit{pending assertions} are posted on-chain and they are open to dispute. Once the challenge period is over and no challenge is submitted, the assertion is confirmed and the CallMarket contract transitions to the new state (\ie updates traders' balances). This scheme takes the overhead for the CallMarket contract to execute the \texttt{Close()} on-chain by using rounds to the dispute resolutions. The two parties (asserter and challenger) must run an interactive protocol and the CallMarket smart contract would have to act as a referee and decides which party's claim is true. Arbitrum is an example of multi-round interactive rollups that uses an efficient challenge-based protocol to penalize the dishonest parties~\cite{kalodner2018arbitrum}. 
%
%%= = = = = =  = =  =  SGX=  = = = = = = = = =%
%
%\paragraph{{Using Trusted Execution Environments.}} Another way of achieving execution of the \texttt{CloseMarket()} function is incorporating the Ethereum blockchain into the Trusted Execution Environments (TEEs) and decoupling the contract execution from consensus mechanism. TEEs enable secure execution of applications in an isolated processing environment called the \textit{enclave}. Here, the enclave could execute the \texttt{CloseMarket()} function off-chain in TEEs and publish an on-chain attestation Quote to the CallMarket contract. The contract then verifies the correctness of the Quote and if validated correctly, it transitions to the new state. Ekiden is an example that uses Intel SGX to solve the scalability and confidentiality issues with the smart contract execution~\cite{cheng2019ekiden}. A drawback of this scheme is in order to achieve confidentiality-preserving smart contracts we have to trust a trusted party in the form of the hardware manufacturer (\eg Intel).


