% !TEX root = ../main.tex


\section{Introductory Remarks}


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Related Work}



% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
%Mahsa
%Notes related to design and implementations


Executed orders are permanently deleted from the storage instantly. 



Deletion
Ethereum gives us a gas refund when we delete variables. Its purpose is an incentive to save space on the blockchain, we use it to reduce the gas cost of our transactions.
Deleting a variable refunds 15,000 gas up to a maximum of half the gas cost of the transaction. Deleting with the delete keyword is equivalent to assigning the initial value for the data type, such as 0 for integers.





Appendix G. Fee Schedule in the Yellow Paper-EIP-150, shows that a gas refund of 15,000 is given for each state slot that is set to zero. These refunds are calculated during execution but only paid back post-execution.
The Fee Schedule also states that changing a store from a Zero value costs 20,000 but changing a non-Zero store costs only 5000. The notable difference being the 15,000 refund.
So the net cost of a store and delete is 5000 gas. If the entire 20,000 gas or more was refunded, then there is effectively no net cost for storage operations and its IO overhead. A cheap attack could be launched by continuous store/delete.

heap-mapping with delete mapping (30 orders) : 3,111,416
heap-mapping without delete mapping (30 orders) : 3,582,291


You should be aware the refund is done at the end of the transaction, you have to have enough gas to process each slot upfront. Also your refund can be at most half of the gas used
Recall that the gas refund can give you up to half of your consumed gas back, so even in the best case, you won't actually break even.

GasToken works by taking advantage of the storage refund in Ethereum

Store data permanently on Ethereum is extremely expensive. It has no 

DApps on Ethereum execute arbitrary code provided by the owner of the DApp. While this code might be writtenin a high-level programming language like Solidity, it is compiled to a compact representation (called ‘bytecode’)that is a set of low-level instructions to the environment (Ethereum virtual machine or EVM). Because differentfunctions will have different complexities, the user running the function pays in proportion to the number ofinstructions, the complexity of the instructions, and the storage requirements. This means that each operation has a fixed price. Naturally the operations might be priced in ETH, since it is the on-board currency, however thiswould cause the price of computation to be as volatile as Ether itself. Instead, Ethereum uses a pseudo-currencycalled gas.5 Each instruction has a fixed price in gas. A user who wants to run a function will offer to pay a certainamount of ETH per unit of gas to the miner who finalizes the function. Miners will generally choose whichfunctions to run first based on how much ETH/gas they offer, and they might ignore functions that offer too littleETH/gas. We describe gas as a pseudo-currency because it cannot be directly stored or transacted, however wewill revisit this below



The obvious is answer is that you can receive gas refunds for releasing unused storage. In the yellow paper on page 25 'Appendix G. Fee Schedule', you can read the gas costs for each instruction. As you might know, SSTORE will generally create the most costs in your contracts with a significant cost of 20,000 gas per instruction. On the contrary, if you look at R_sclear:

Refund given when the storage value is set to zero from non-zero.

15,000 gas refund means you can actually get 75% of your storing costs back! That is a large amount, do not forget about this. And the solution is simple, just set a value back to 0 once you are sure it will not be used anymore.








The only two OPCODEs with negative gas costs are STORAGEKILL(-15000) and GSUICIDEREFUND(-24000).

These occur when storage values are deleted or contacts are suicided.

These OPCODEs grant gas refunds because they free up space in the blockchain.



Also, Solidity \textit{delete()} function does not 



Clearing Mappings

The Solidity type mapping (see Mapping Types) is a storage-only key-value data structure that does not keep track of the keys that were assigned a non-zero value. Because of that, cleaning a mapping without extra information about the written keys is not possible. (from : https://solidity.readthedocs.io/en/v0.5.12/security-considerations.html) So in order to wipe the unavailable Ether and token balances of all the market participants after matching is completed, we have to iterate over mapping using an array we use to store the mapping keys.





In short, the sender of the transaction that causes the storage location to be freed (set to zero) will have an amount (a net 10000 gas per freed storage location) deducted from the total amount of gas used for the transaction.

It's a bit more nuanced in reality:

The gas cost of setting the location to zero is 5000 (G_sreset in the Yellow Paper).
15000 gas is added into the refund counter (R_sclear in the Yellow Paper).
At the end of a successful transaction the amount of gas in the refund counter (up to a cap of half the total gas used) is added to the unused gas and returned to the caller (Eqn 72 in the Yellow Paper).
References above are to this version of the Yellow Paper, which discusses the Refund Counter in sections 6.1 and 6.2.

The gas price is whatever gas price applies to the whole transaction in which the refund occurs




delete a assigns the initial value for the type to a. I.e. for integers it is equivalent to a = 0, but it can also be used on arrays, where it assigns a dynamic array of length zero or a static array of the same length with all elements reset. For structs, it assigns a struct with all members reset.

delete has no effect on whole mappings (as the keys of mappings may be arbitrary and are generally unknown). So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings. However, individual keys and what they map to can be deleted.











EIP-114, or the “1/64ths rule”
EIP-114 mandates that certain stackdepth-creating opcodes withhold 1/64th of remaining gas from the stack they create. In practice this means:
The gas required for a successful transaction can be greater than the actual gas spent (similar to how gas refunds behave).
The extra gas required for a successful transaction varies depending on the transaction’s initial gasamount.
A long-standing issue with Ganache has been the fact that we haven’t returned EIP-114 compliant gas estimations. This has caused our gas estimates to be too low in cases where a transaction executed certain opcodes. Gas exactimation addresses this by considering how the gas withheld at any nested stack depth/frame affects the gas needed outside of its execution context.
Let’s see it in action


Callstack Depth (hijacked stack/revert)

External function calls can fail any time because they exceed the maximum call stack of 1024. In such situations, Solidity throws an exception.



%If a transaction runs out of gas before successful completion, then all execution reverts.


It is important to note that delete a really behaves like an assignment to a, i.e. it stores a new object in a.

%============= Test 1 (17_Worst_Case_Matching_test.js) Tables==================== %
 \section{Worst Case Matching}
 We run the same truffle test on the five priority queues to examine them in terms of the number of order the call market contract can match.
 Note that this is a worst case matching where we use same prices for bid and ask orders. In this case, all orders will be executed against each other.
 Deliverables of this code are: (1) The maximum number of orders the call market can match (2) How much gas the match function uses (which should be close to the limit)
Results are provided in Table~\ref{tab:worst_case_matching}.


\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Priority Queue} & \textbf{Maximum Number of Matched Orders} & \textbf{Gas Cost in Ether}  \\ \hline
 
Heap with Dynamic Array & 26 pairs & 3,274,994 \\ \hline
Heap with Static Array & 28 pairs & 3,107,938 \\ \hline
Mapping with keys stored in Heap & 40 pairs & 5,416,225 \\ \hline
Linkedlist & 95 pairs & 3,336,416 \\ \hline
Linkedlist with Mapping & 130 pairs & 3,302,908 \\ \hline

\end{tabular}
\caption{\footnotesize{}\label{tab:worst_case_matching}}
\end{table}

%============= Test 1 (18_Average_Case_Matching_test.js) Tables==================== %
 \section{Normal/Average Case Matching}
 

 
PQ1 Heap with dynamic array:

 PQ1 can handle 26 pairs at max (we got this from worst case matching), so we run the average test on it (for 5 times to get the average) with 26 asks and 26 bids BUT with random prices (so not all of them are going to match)
%====%
26 bids - 26 asks : 
1- 16 matched, 3,022,922
2- 14 matched, 2,630,179
3- 13 matched, 2,756,139
4- 14 matched, 2,677,851
5 - 13 matched, 2,484,512
%================================================%
PQ2 Heap with static array:

 PQ2 can handle 28 pairs at max (we got this from worst case matching), so we run the average test on it (for 5 times to get the average) with 28 asks and 28 bids BUT with random prices (so not all of them are going to match)
%====%
28 bids - 28 asks : 
1- 11 matched, 1,768,494
2- 12 matched, 2,045,830
3- 16 matched, 2,420,384
4- 17 matched, 2,523,974
5- 14 matched, 2,234,141
%================================================%
PQ3 Mapping with keys stored in Heap:

 PQ3 can handle 40 pairs at max (we got this from worst case matching), so we run the average test on it (for 5 times to get the average) with 40 asks and 40 bids BUT with random prices (so not all of them are going to match)
%====%
40 bids - 40 asks : 
1- 23 matched, 4,349,561
2- 20 matched, 3,888,163
3- 20 matched, 3,915,233
4- 20 matched, 3,899,789
5- 23 matched, 4,308,653

%================================================%
PQ4 Linkedlist

PQ4 can handle 95 pairs at max (we got this from worst case matching), so we run the average test on it (for 5 times to get the average) with 95 asks and 95 bids BUT with random prices (so not all of them are going to match)
%====%
95 bids - 95 asks : 
1- 48 matched , 1,747,421
2- 46 matched, 1,678,536
3- 41 matched, 1,506,325
4- 51 matched, 1,850,748
5- 49 matched, 1,781,863

%================================================%
PQ5 Linkedlist with Mapping

PQ5 can handle 130 pairs at max (we got this from worst case matching), so we run the average test on it (for 5 times to get the average) with 130 asks and 130 bids BUT with random prices (so not all of them are going to match)
%====%
130 bids - 130 asks : 
1- 64 matched, 1,669,482
2- 11 matched, 341,421
3- 39 matched, 1,043,014
4- 59 matched, 1,544,185
5- 36 matched, 967,840





 We run the same truffle test on the five priority queues to examine them in terms of the number of order the call market contract can match.
 Note that this is an average case matching where we use random prices for bid and ask orders.
 Deliverables of this code are: (1) The maximum number of orders the call market can match (2) How much gas the match function uses (which should be close to the limit)
Results are provided in Table~\ref{tab:normal_case_matching}.


\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{Priority Queue} & \textbf{Maximum Number of Matched Orders} & \textbf{Gas Cost in Ether}  \\ \hline
 
Heap with Dynamic Array &  &  \\ \hline
Heap with Static Array &  &  \\ \hline
Mapping with keys stored in Heap &  &  \\ \hline
Linkedlist &  &  \\ \hline
Linkedlist with Mapping && \\ \hline

\end{tabular}
\caption{\footnotesize{}\label{tab:normal_case_matching}}
\end{table}























\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{\shortstack{Number \\of \\Buy Orders}} & \textbf{\shortstack{Number \\of \\Sell Orders}} & \textbf{\shortstack{Total Number \\of\\ Orders}}  & \textbf{\shortstack{Gas Cost \\in\\ Ether}}  \\ \hline
1 & 1 & 2 & 144,689 \\
3 & 3 & 6 & 324,457 \\
5 & 5 & 10 & 527,289 \\
7 & 7 & 14 & 710,050 \\
9 & 9 & 18 & 964,894 \\
11 & 11 & 22 & 1,176,905 \\
13 & 13 & 26 & 1,370,191 \\
15 & 15 & 30 & 1,650,273 \\
17 & 17 & 34 & 1,953,406 \\
19 & 19 & 38 & 2,205,141 \\
21 & 21 & 42 & 2,416,221 \\
23 & 23 & 46 & 2,713,313 \\
25 & 25 & 50 & 1,788,509 \\
27 & 27 & 54 & 2,004,824 \\
\hline
29 & 29 & 58 & \textbf{out of gas}\\
\hline
\end{tabular}
\caption{\footnotesize{Gas used for Match function when using static arrays to store the heap.}\label{}} %Orderbook_V23
\end{table}




\begin{table}[t]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{\shortstack{Number \\of \\Buy Orders}} & \textbf{\shortstack{Number \\of \\Sell Orders}} & \textbf{\shortstack{Total Number \\of\\ Orders}}  & \textbf{\shortstack{Gas Cost \\in\\ Ether}}  \\ \hline
1 & 1 & 2 & 177,622 \\
3 & 3 & 6 &  341,393\\
5 & 5 & 10 & 524,680 \\
7 & 7 & 14 & 685,830\\
9 & 9 & 18 & 919,636 \\
11 & 11 & 22 & 1,094,503  \\
13 & 13 & 26 & 1,347,199 \\
15 & 15 & 30 & 1,559,796 \\
17 & 17 & 34 & 1,792,040 \\
19 & 19 & 38 & 2,076,422 \\
21 & 21 & 42 & 2,294,229 \\
23 & 23 & 46 & 2,532,674 \\
25 & 25 & 50 & 2,776,988 \\
27 & 27 & 54 & 3,069,163 \\
29 & 29 & 58 & 3,306,749\\
31 & 31 & 62 & 3,551,195\\
\hline
33 & 33 & 66 & \textbf{out of gas} \\
\hline
\end{tabular}
\caption{\footnotesize{Gas used for Match function when storing the order structs in mappings and storing the keys in the dynamic arrays that represent sorted heap.}\label{}} %Orderbook_V24
\end{table}


%======================================== %
\section{Performance Tests on Different Datastructures}

%===Heap that is stored in dynamically sized array=== %
\subsection{Heap that is stored in dynamically sized array}
Here is the gas cost used for storing N order struct, sorting, and removing them from the heap
Order structs are stored in a heap with dynamic array

%\begin{table}[t]
%\centering
%\begin{tabular}{|c|c|c|}
%\hline
%\textbf{\shortstack{Number \\of \\ Orders}} & \textbf{\shortstack{Gas Cost \for Insertion\\ in Ether}}  \textbf{\shortstack{Gas Cost \for Removing\\ in Ether}} \\ \hline
%1 & 105,118 & 24,430  \\
%3 & 331,448 & 88,904 \\
%5 & 603,874 & 184,089 \\
%7 & 876,300 & 279,312 \\
%9 & 1,194,820 & 430,737 \\
%11 & 1,513,340 & 582,200 \\
%13 & 1,831,860 & 733,663 \\
%15 & 2,150,380 & 885,164 \\
%17 & 2,514,996 & 1,092,829 \\
%19 & 2,879,612 & 1,300,532 \\
%21 & 3,244,228 & 1,508,235 \\
%23 & 3,608,844 & 1,715,976 \\
%25 & 3,973,460 & 1,923,679 \\
%27 & 4,338,076 & 2,131,420 \\
%29 & 4,702,692 & 2,339,161 \\
%31 & 5,067,308 & 2,546,940 \\
%33 & 5,478,020 & 2,810,845 \\
%35 & 5,888,732 & 3,074,788\\
%37 & 6,299,444 & 3,338,731\\
%39 & 6,710,156 & 3,602,712 \\
%41 &  &  \\
%43 &  &  \\
%45 &  &  \\
%47 &  &  \\
%39 &  &  \\
%39 &  &  \\
%37 &  &  \\
%39 &  &  \\
%
%
%
%\hline
%
%
%
%
%
%
%33 & 33 & 66 & \textbf{out of gas} \\
%\hline
%\end{tabular}
%\caption{\footnotesize{Gas used for insertion() and remove() functions when using dynamic arrays to store the heap}\label{}} %Heap_Dynamic_Array.sol
%\end{table}
%======================================== %

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Concluding Remarks}


 
%\subsubsection*{Acknowledgements.} J. Clark thanks ...

































